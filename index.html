<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luxury 3D Particle Christmas Tree | æå…‰åœ£è¯</title>
    
    <!-- å­—ä½“å¼•å…¥ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <!-- Merry Christmas ä¸“ç”¨è‰ºæœ¯å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

    <!-- MediaPipe ä¾èµ– -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>

    <!-- Firebase ä¾èµ– -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getAuth, signInAnonymously, signInWithCustomToken } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';
        import { getFirestore, collection, addDoc, getDoc, doc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        
        window.FirebaseSDK = { initializeApp, getAuth, signInAnonymously, signInWithCustomToken, getFirestore, collection, addDoc, getDoc, doc };
    </script>

    <style>
        /* CSS Reset & åŸºç¡€æ ·å¼ */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            width: 100vw;
            height: 100vh;
            background-color: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
            color: #D4AF37; /* å¥¢åé‡‘ */
            cursor: none; /* éšè—é»˜è®¤é¼ æ ‡ï¼Œä½¿ç”¨æ‰‹åŠ¿å…‰æ ‡ */
        }

        /* 3D å®¹å™¨ */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* å®æ—¶æ‘„åƒå¤´é¢„è§ˆ - å³ä¸Šè§’æ‚¬æµ®çª— */
        #input-video {
            display: none;
            position: absolute;
            top: 20px;
            right: 20px;
            left: auto;
            width: 160px; /* ç¨å¾®ç¼©å°ä¸€ç‚¹ */
            height: 120px;
            transform: scaleX(-1);
            z-index: 20;
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            background: #000;
            object-fit: cover;
        }

        /* æ§åˆ¶é¢æ¿æ˜¾éšæŒ‰é’® */
        #toggle-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            z-index: 100;
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(8px);
            border: 1px solid #D4AF37;
            border-radius: 8px;
            color: #D4AF37;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        #toggle-btn:hover {
            background: #D4AF37;
            color: #000;
        }

        /* UI é¢æ¿ - ç£¨ç ‚ç»ç’ƒé£æ ¼ (ç´§å‡‘ç‰ˆ) */
        #ui-panel {
            position: absolute;
            top: 70px; /* æ”¾åœ¨æŒ‰é’®ä¸‹æ–¹ */
            left: 20px;
            width: 260px; /* ç¼©å°å®½åº¦ */
            padding: 15px; /* ç¼©å°å†…è¾¹è· */
            background: rgba(20, 20, 20, 0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 12px;
            z-index: 10;
            transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.4s ease;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            cursor: auto; 
            transform-origin: top left;
        }

        /* éšè—çŠ¶æ€ class */
        #ui-panel.hidden {
            transform: scale(0.9) translateY(-20px);
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 1.2rem; /* ç¼©å°æ ‡é¢˜ */
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 8px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 8px; /* ç¼©å°é—´è· */
        }

        /* æŒ‰é’®æ ·å¼ (ç´§å‡‘) */
        button, .file-upload-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #D4AF37;
            color: #D4AF37;
            padding: 8px; /* ç¼©å°padding */
            font-family: 'Cinzel', serif;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.75rem; /* ç¼©å°å­—ä½“ */
            border-radius: 4px;
            text-align: center;
            display: block;
            width: 100%;
        }

        button:hover, .file-upload-btn:hover {
            background: #D4AF37;
            color: #000;
            box-shadow: 0 0 15px #D4AF37;
        }

        /* ç‰¹æ®ŠæŒ‰é’® */
        #btn-share {
            border-color: #50C878;
            color: #50C878;
        }
        #btn-share:hover {
            background: #50C878;
            color: #000;
        }

        input[type="file"] {
            display: none;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ (ç´§å‡‘) */
        .status-item {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem; /* ç¼©å°å­—ä½“ */
            margin-top: 4px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .status-value {
            color: #D4AF37;
            font-weight: bold;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            transition: opacity 1s ease;
        }
        .loader-text {
            margin-top: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; text-shadow: 0 0 20px #D4AF37; }
            100% { opacity: 0.5; }
        }

        /* äº¤äº’æç¤º */
        #gesture-hint {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.75rem; /* ç¼©å°æç¤ºå­— */
            font-family: 'Cinzel', serif;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 0 5px #000;
            letter-spacing: 1px;
        }

        /* åˆ†äº«å¼¹çª— */
        #share-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 200;
            justify-content: center;
            align-items: center;
            cursor: auto;
        }
        .modal-content {
            background: #1a1a1a;
            border: 2px solid #D4AF37;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
        }
        .modal-content input {
            width: 100%;
            padding: 10px;
            margin: 15px 0;
            background: #222;
            border: 1px solid #555;
            color: #fff;
            border-radius: 4px;
            font-family: monospace;
        }
        .modal-note {
            font-size: 0.85rem;
            color: #ccc;
            margin-bottom: 15px;
            line-height: 1.5;
        }
        .warning-text {
            color: #ff6b6b;
            font-size: 0.8rem;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
        }

        /* è™šæ‹Ÿå…‰æ ‡ */
        #virtual-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid #D4AF37;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 50;
            transition: transform 0.1s;
            box-shadow: 0 0 10px #D4AF37;
            display: none;
        }
        #virtual-cursor.active {
            background: rgba(212, 175, 55, 0.5);
            transform: translate(-50%, -50%) scale(0.8);
        }
        #virtual-cursor.clicking {
            background: #50C878;
            border-color: #50C878;
            transform: translate(-50%, -50%) scale(1.2);
            box-shadow: 0 0 20px #50C878;
        }

    </style>
</head>
<body>

    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loader">
        <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="#D4AF37" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
            <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
        </svg>
        <div class="loader-text">Loading Experience...</div>
    </div>

    <!-- åˆ†äº«å¼¹çª— -->
    <div id="share-modal">
        <div class="modal-content">
            <h2 style="color: #D4AF37; margin-bottom: 10px;">Link Generated!</h2>
            <div class="modal-note">
                Success! Your tree configuration has been saved to the cloud.<br>
                Use the link below to share your creation.
            </div>
            
            <input type="text" id="share-link-input" readonly>
            
            <div id="preview-warning" class="warning-text" style="display:none;">
                âš ï¸ <b>Preview Environment Detected</b><br>
                This "blob:" link is local-only and cannot be opened by others. 
                To share properly, please deploy this HTML file to a web server (e.g., GitHub Pages).
            </div>

            <button onclick="document.getElementById('share-modal').style.display='none'">Close</button>
        </div>
    </div>

    <!-- é¢æ¿å¼€å…³æŒ‰é’® -->
    <button id="toggle-btn" onclick="toggleUI()">â˜°</button>

    <!-- UI é¢æ¿ -->
    <div id="ui-panel">
        <h1>Midnight Aurora</h1>
        <div class="controls">
            <button id="btn-camera">ğŸ“¸ Start Gesture (Start)</button>
            <label class="file-upload-btn">
                ğŸµ Upload Music
                <input type="file" id="music-upload" accept="audio/*">
            </label>
            <label class="file-upload-btn">
                ğŸ–¼ï¸ Upload Photos
                <input type="file" id="photo-upload" accept="image/*" multiple>
            </label>
            <button id="btn-share">ğŸ”— Share Link</button>
            <button id="btn-fullscreen">â›¶ Fullscreen</button>
            
            <div style="margin-top: 15px; border-top: 1px solid rgba(212,175,55,0.2); padding-top:10px;">
                <div class="status-item">
                    <span>Left (Action):</span>
                    <span id="status-left" class="status-value">Wait...</span>
                </div>
                <div class="status-item">
                    <span>Right (Control):</span>
                    <span id="status-right" class="status-value">Wait...</span>
                </div>
                <div class="status-item">
                    <span>Mode:</span>
                    <span id="status-mode" class="status-value">Tree</span>
                </div>
            </div>
        </div>
    </div>

    <div id="gesture-hint">Left Hand: Open & Move to Rotate | Right Hand: Pinch to Select/Close-up</div>
    <div id="virtual-cursor"></div>

    <!-- éšè—è§†é¢‘è¾“å…¥ -->
    <video id="input-video"></video>

    <!-- Three.js å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- ES Module é€»è¾‘ -->
    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            colors: {
                gold: new THREE.Color(0xFFD700),
                red: new THREE.Color(0x8B0000),
                emerald: new THREE.Color(0x50C878),
                white: new THREE.Color(0xFFFFFF),
                photoBase: new THREE.Color(0x444444) 
            },
            particleCount: {
                tree: 6000,
                dust: 2000,
                ribbon: 1500,
                snow: 1000 
            },
            treeHeight: 60,
            treeRadius: 25
        };

        // --- æ ¸å¿ƒçŠ¶æ€ ---
        const STATE = {
            // ç²’å­çŠ¶æ€
            explosionFactor: 0,
            isExploded: false,
            
            // äº¤äº’çŠ¶æ€
            isGalleryMode: false,
            galleryRotation: 0,
            galleryVelocity: 0,
            
            // èšç„¦çŠ¶æ€
            focusTarget: null,
            isFocusing: false,
            
            // æ‰‹åŠ¿è¾“å…¥
            cursorPos: new THREE.Vector2(),
            lastPinchTime: 0,
            
            // éŸ³é¢‘
            audioData: 0,
            audioCtx: null,
            currentMusicName: "",
            
            // å¸¸é‡
            originalCameraPos: new THREE.Vector3(0, 30, 100),
            galleryCameraPos: new THREE.Vector3(0, 30, 80)
        };

        // --- UI æ§åˆ¶é€»è¾‘ ---
        window.toggleUI = () => {
            const panel = document.getElementById('ui-panel');
            panel.classList.toggle('hidden');
        };

        // --- Firebase & Share Logic ---
        let db, appId;
        const currentPhotos = []; // Base64 data

        const initFirebase = async () => {
            // 1. å¼•å…¥ Firebase SDK åŠŸèƒ½
            const { initializeApp, getAuth, signInAnonymously, 			signInWithCustomToken, getFirestore, collection, addDoc, getDoc, 	doc } = window.FirebaseSDK;

            // 2. ç²˜è´´æ‚¨åˆšæ‰å¤åˆ¶çš„é…ç½® (æ³¨æ„ï¼šè¦æ˜¯æ‚¨è‡ªå·±çš„çœŸå®æ•°æ®)
            const firebaseConfig = {
                apiKey: "AIzaSyDPJ6mZ24Yl2ji4JOq4J2tWIuzMZX4ldFw",
  		authDomain: "blueeee-63455.firebaseapp.com",
  		projectId: "blueeee-63455",
  		storageBucket: "blueeee-63455.firebasestorage.app",
  		messagingSenderId: "199195705398",
  		appId: "1:199195705398:web:14f4004273c64e2d245897",
  		measurementId: "G-BSEYZK3D9P"
            };

            // 3. åˆå§‹åŒ–
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            db = getFirestore(app);
            appId = "christmas-tree-v1"; // è¿™é‡Œå¯ä»¥éšä¾¿å†™ä¸ªåå­—ä½œä¸ºID

            // 4. ç™»å½•é€»è¾‘ (æœ¬åœ°è¿è¡Œä¸éœ€è¦ CustomTokenï¼Œç›´æ¥åŒ¿åç™»å½•)
            try {
                await signInAnonymously(auth);
                console.log("Logged in anonymously");
            } catch (error) {
                console.error("Auth failed:", error);
            }
            const app = initializeApp(firebaseConfig);
            const auth = getAuth(app);
            db = getFirestore(app);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed:", error);
            }

            // Check URL for share ID
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            if (shareId) {
                loadSharedTree(shareId);
            }
        };

        // Compress image for storage
        const compressImage = (fileOrUrl) => {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const MAX_SIZE = 512; 
                    let width = img.width;
                    let height = img.height;
                    
                    if (width > height) {
                        if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; }
                    } else {
                        if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; }
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    resolve(canvas.toDataURL('image/jpeg', 0.6));
                };
                if (typeof fileOrUrl === 'string') img.src = fileOrUrl;
                else {
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(fileOrUrl);
                }
            });
        };

        document.getElementById('btn-share').addEventListener('click', async () => {
            const btn = document.getElementById('btn-share');
            if (currentPhotos.length === 0) {
                alert("Please upload photos first!");
                return;
            }
            
            btn.disabled = true;
            btn.innerText = "Uploading...";

            try {
                const { collection, addDoc } = window.FirebaseSDK;
                const colRef = collection(db, 'artifacts', appId, 'public', 'data', 'shared_trees');
                
                // Limit to 5 photos to stay safe within 1MB doc limit
                const photosToSave = currentPhotos.slice(0, 5); 
                
                const docRef = await addDoc(colRef, {
                    photos: photosToSave,
                    musicName: STATE.currentMusicName || "Unknown",
                    timestamp: new Date().toISOString()
                });

                // Generate Link
                const baseUrl = window.location.href.split('?')[0];
                const shareUrl = `${baseUrl}?share=${docRef.id}`;
                
                // Show Modal
                const modal = document.getElementById('share-modal');
                const input = document.getElementById('share-link-input');
                const warning = document.getElementById('preview-warning');
                
                input.value = shareUrl;
                modal.style.display = 'flex';
                
                // Warn about blob URLs
                if (window.location.protocol === 'blob:' || window.location.href.includes('usercontent.goog')) {
                    warning.style.display = 'block';
                } else {
                    warning.style.display = 'none';
                }
                
                // Copy
                input.select();
                document.execCommand('copy');
                
            } catch (e) {
                console.error("Share failed", e);
                alert("Share failed: " + e.message);
            } finally {
                btn.disabled = false;
                btn.innerText = "ğŸ”— Share Link";
            }
        });

        const loadSharedTree = async (shareId) => {
            const loaderText = document.querySelector('.loader-text');
            loaderText.innerText = "Loading Shared Tree...";
            
            try {
                const { doc, getDoc } = window.FirebaseSDK;
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'shared_trees', shareId);
                const snapshot = await getDoc(docRef);

                if (snapshot.exists()) {
                    const data = snapshot.data();
                    if (data.musicName) {
                        alert(`This share includes visual effects.\nSender's music: "${data.musicName}"\nUpload same music for best experience.`);
                    }
                    
                    if (data.photos) {
                        photoMeshes.forEach(m => photoGroup.remove(m));
                        photoMeshes.length = 0;
                        currentPhotos.length = 0;
                        photoTreePositions.length = 0;
                        
                        data.photos.forEach((base64, i) => {
                            createPhotoMesh(base64, i, data.photos.length);
                            currentPhotos.push(base64);
                        });
                    }
                } else {
                    alert("Invalid share link");
                }
            } catch (e) {
                console.error("Load failed", e);
            }
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        scene.fog = new THREE.FogExp2(0x050505, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.copy(STATE.originalCameraPos);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;
        controls.maxDistance = 200;

        // --- Bloom åå¤„ç† ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.1);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- Raycaster (ç”¨äºç‚¹å‡»æ£€æµ‹) ---
        const raycaster = new THREE.Raycaster();
        
        // --- Shader (ç²’å­ç³»ç»Ÿ - åŒ…å«é›ªèŠ±) ---
        const vertexShader = `
            uniform float uTime;
            uniform float uExplosion;
            uniform float uAudio;
            uniform float uPixelRatio;
            uniform float uFocusMode; // 1.0 = focusing (dim particles)

            attribute vec3 aScatterPos;
            attribute float aSize;
            attribute vec3 aColor;
            attribute float aType; // 0:Tree, 1:Dust, 2:Ribbon, 3:Snow

            varying vec3 vColor;
            varying float vOpacity;

            void main() {
                vColor = aColor;
                vec3 pos = position;
                float alphaFade = 1.0;

                // --- èºæ—‹å…‰å¸¦é€»è¾‘ ---
                if (aType > 1.5 && aType < 2.5) { // Type 2: Ribbon
                    float bottomY = -30.0;
                    float topY = 32.0; 
                    float heightRange = topY - bottomY;
                    float speed = 15.0; 
                    float currentY = mod(pos.y + uTime * speed - bottomY, heightRange) + bottomY;
                    float progress = (currentY - bottomY) / heightRange;
                    float currentRadius = mix(35.0, 0.0, progress); 
                    currentRadius += sin(currentY * 0.5 + uTime) * 0.5;
                    float currentAngle = progress * 30.0 - uTime * 0.5; // Reduced from 2.0 to 0.5 for slower rotation
                    
                    pos.x = currentRadius * cos(currentAngle);
                    pos.z = currentRadius * sin(currentAngle);
                    pos.y = currentY;

                    alphaFade = smoothstep(0.0, 0.1, progress) * (1.0 - smoothstep(0.8, 1.0, progress));
                }

                // --- é›ªèŠ±é€»è¾‘ (æ…¢é€Ÿ) ---
                if (aType > 2.5) { // Type 3: Snow
                    float fallSpeed = 3.0 + aSize * 2.0; 
                    float sway = sin(uTime * 0.5 + pos.x) * 1.5; 
                    
                    // æ— é™ä¸‹è½å¾ªç¯
                    pos.y = mod(pos.y - uTime * fallSpeed + 50.0, 100.0) - 50.0;
                    pos.x += sway;
                    pos.z += cos(uTime * 0.5 + pos.y) * 1.5;
                }

                float beat = 1.0;
                if (aType < 0.5 || (aType > 1.5 && aType < 2.5)) {
                    beat = 1.0 + uAudio * 0.8; 
                }

                // çˆ†ç‚¸æ’å€¼
                vec3 finalPos = mix(pos, aScatterPos, uExplosion);
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                
                gl_PointSize = aSize * beat * uPixelRatio * (200.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;

                // é€æ˜åº¦æ§åˆ¶
                float baseOpacity = 1.0 - (uExplosion * 0.3);
                float focusDim = 1.0 - (uFocusMode * 0.85); 
                
                vOpacity = baseOpacity * alphaFade * focusDim;
            }
        `;

        const fragmentShader = `
            varying vec3 vColor;
            varying float vOpacity;
            void main() {
                float d = distance(gl_PointCoord, vec2(0.5));
                if (d > 0.5) discard;
                float strength = 1.0 - (d * 2.0);
                strength = pow(strength, 1.5);
                gl_FragColor = vec4(vColor, vOpacity * strength);
            }
        `;

        // --- ç²’å­ç”Ÿæˆ ---
        const particlesGeometry = new THREE.BufferGeometry();
        const positions = []; const scatterPositions = []; const colors = []; const sizes = []; const types = [];
        const vec = new THREE.Vector3(); const color = new THREE.Color();

        // æ ‘
        for (let i = 0; i < CONFIG.particleCount.tree; i++) {
            const h = Math.random() * CONFIG.treeHeight;
            const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius;
            const r = Math.random() * maxR;
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta); const y = h - (CONFIG.treeHeight / 2); const z = r * Math.sin(theta);
            positions.push(x, y, z);
            vec.set(x, y, z).normalize().multiplyScalar(50 + Math.random() * 100);
            scatterPositions.push(vec.x, vec.y, vec.z);
            const rand = Math.random();
            if (rand < 0.6) color.copy(CONFIG.colors.gold); else if (rand < 0.8) color.copy(CONFIG.colors.red); else color.copy(CONFIG.colors.emerald);
            colors.push(color.r, color.g, color.b);
            sizes.push(Math.random() * 0.8 + 0.5);
            types.push(0);
        }
        // å°˜åŸƒ
        for (let i = 0; i < CONFIG.particleCount.dust; i++) {
            const range = 100;
            const x = (Math.random() - 0.5) * range; const y = (Math.random() - 0.5) * range; const z = (Math.random() - 0.5) * range;
            positions.push(x, y, z);
            scatterPositions.push(x * 1.5, y * 1.5, z * 1.5);
            colors.push(0.6, 0.6, 0.8);
            sizes.push(Math.random() * 0.5 + 0.2);
            types.push(1);
        }
        // èºæ—‹
        for (let i = 0; i < CONFIG.particleCount.ribbon; i++) {
            const t = i / CONFIG.particleCount.ribbon;
            const h = t * CONFIG.treeHeight - (CONFIG.treeHeight / 2);
            positions.push(0, h, 0);
            vec.set(Math.random()-0.5, 0, Math.random()-0.5).normalize().multiplyScalar(80);
            scatterPositions.push(vec.x, (Math.random()-0.5)*100, vec.z);
            color.copy(CONFIG.colors.gold);
            colors.push(color.r + 0.2, color.g + 0.2, color.b);
            sizes.push(Math.random() * 1.5 + 1.0);
            types.push(2);
        }
        // é›ªèŠ± (Type 3)
        for (let i = 0; i < CONFIG.particleCount.snow; i++) {
            const range = 100;
            const x = (Math.random() - 0.5) * range;
            const y = (Math.random() - 0.5) * range;
            const z = (Math.random() - 0.5) * range;
            positions.push(x, y, z);
            vec.set(x, y, z).multiplyScalar(2.0);
            scatterPositions.push(vec.x, vec.y, vec.z);
            colors.push(1.0, 1.0, 1.0);
            sizes.push(Math.random() * 0.8 + 0.4);
            types.push(3);
        }

        particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        particlesGeometry.setAttribute('aScatterPos', new THREE.Float32BufferAttribute(scatterPositions, 3));
        particlesGeometry.setAttribute('aColor', new THREE.Float32BufferAttribute(colors, 3));
        particlesGeometry.setAttribute('aSize', new THREE.Float32BufferAttribute(sizes, 1));
        particlesGeometry.setAttribute('aType', new THREE.Float32BufferAttribute(types, 1));

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: { 
                uTime: { value: 0 }, 
                uExplosion: { value: 0 }, 
                uAudio: { value: 0 }, 
                uPixelRatio: { value: renderer.getPixelRatio() },
                uFocusMode: { value: 0 }
            },
            vertexShader, fragmentShader, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        const particleSystem = new THREE.Points(particlesGeometry, particleMaterial);
        scene.add(particleSystem);

        // --- æ˜Ÿæ˜Ÿ ---
        const starShape = new THREE.Shape();
        const outerRadius = 2.5; const innerRadius = 1.0; const pts = 5;
        for (let i = 0; i < pts * 2; i++) {
            const r = (i % 2 === 0) ? outerRadius : innerRadius;
            const a = (i / (pts * 2)) * Math.PI * 2;
            const x = Math.cos(a) * r; const y = Math.sin(a) * r;
            if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
        }
        starShape.closePath();
        const starGeo = new THREE.ExtrudeGeometry(starShape, { depth: 0.5, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.1 });
        const starMat = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.y = CONFIG.treeHeight / 2 + 2;
        scene.add(starMesh);

        // --- "Merry Christmas" æ–‡æœ¬æ ‡ç­¾ ---
        const createTextLabel = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 2048; // åˆ†è¾¨ç‡ç¿»å€ï¼Œé˜²æ­¢æ¨¡ç³Š
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // å­—ä½“è®¾ç½®: å­—å·æ”¾å¤§ä¸€å€
            ctx.font = "italic 200px 'Great Vibes', cursive";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // é¢œè‰²ä¸å‘å…‰
            // å¤–å‘å…‰ (Shadow)
            ctx.shadowColor = "#87CEFA"; 
            ctx.shadowBlur = 40; // æ¨¡ç³ŠåŠå¾„ä¹Ÿé€‚å½“å¢åŠ 
            // æ–‡æœ¬å¡«å……é¢œè‰² (æµ…è“)
            ctx.fillStyle = "#ADD8E6";
            
            // ç»˜åˆ¶æ–‡å­—
            ctx.fillText("Merry Christmas", canvas.width / 2, canvas.height / 2);
            
            // åˆ›å»ºè´´å›¾
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending // å åŠ æ¨¡å¼å¢å¼ºå‘å…‰
            });
            
            const sprite = new THREE.Sprite(material);
            // è°ƒæ•´å¤§å°: 3D ä¸–ç•Œä¸­çš„å°ºå¯¸ä¹Ÿæ”¾å¤§ä¸€å€
            sprite.scale.set(60, 15, 1);
            // ä½ç½®: æ˜Ÿæ˜Ÿä¸Šæ–¹
            sprite.position.y = CONFIG.treeHeight / 2 + 15; // ç¨å¾®è°ƒé«˜ä¸€ç‚¹ä½ç½®
            
            // æ·»åŠ åˆ°æ˜Ÿæ˜Ÿç»„æˆ–è€…ç›´æ¥åœºæ™¯
            scene.add(sprite);
            
            // ç®€å•çš„æµ®åŠ¨åŠ¨ç”»
            sprite.userData = { initialY: sprite.position.y };
            return sprite;
        };
        
        // ç­‰å¾…å­—ä½“åŠ è½½å®Œæˆååˆ›å»º (æ³¨æ„è¿™é‡Œä¹Ÿæ”¹ä¸º 200px)
        document.fonts.load("200px 'Great Vibes'").then(createTextLabel);

        // --- è£…é¥°å“ç®¡ç† (Meshes) ---
        const decorationGroup = new THREE.Group();
        scene.add(decorationGroup);
        const decorationMeshes = [];

        const createDecorations = () => {
            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const matRed = new THREE.MeshStandardMaterial({ color: 0xFF0000, metalness: 0.7, roughness: 0.2 });
            const matGold = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8, roughness: 0.1 });
            const matSilver = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, metalness: 0.9, roughness: 0.1 });
            
            // è£…é¥°å½©çƒ
            for(let i=0; i<50; i++) {
                let mat;
                const r = Math.random();
                if(r < 0.4) mat = matRed; else if(r < 0.7) mat = matGold; else mat = matSilver;

                const mesh = new THREE.Mesh(sphereGeo, mat);
                const h = Math.random() * (CONFIG.treeHeight - 5);
                const maxR = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius;
                const rad = Math.random() * maxR;
                const ang = Math.random() * Math.PI * 2;
                const px = Math.cos(ang) * rad;
                const py = h - CONFIG.treeHeight/2;
                const pz = Math.sin(ang) * rad;
                
                mesh.position.set(px, py, pz);
                mesh.userData = {
                    treePos: new THREE.Vector3(px, py, pz),
                    treeScale: new THREE.Vector3(0.5 + Math.random()*0.5, 0.5 + Math.random()*0.5, 0.5 + Math.random()*0.5),
                    scatterPos: new THREE.Vector3(px, py, pz).normalize().multiplyScalar(40 + Math.random()*30)
                };
                mesh.scale.copy(mesh.userData.treeScale);
                decorationGroup.add(mesh);
                decorationMeshes.push(mesh);
            }
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);
        };
        createDecorations();

        // --- ç…§ç‰‡å¢™ç®¡ç† ---
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);
        const photoMeshes = [];

        const createPhotoMesh = (src, index, total) => {
             const img = new Image();
             img.crossOrigin = "Anonymous";
             img.src = src;
             img.onload = () => {
                const texture = new THREE.Texture(img);
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.needsUpdate = true;
                const mat = new THREE.MeshBasicMaterial({ map: texture, color: CONFIG.colors.photoBase, side: THREE.DoubleSide });
                const aspect = img.width / img.height;
                const geo = new THREE.PlaneGeometry(5 * aspect, 5);
                const mesh = new THREE.Mesh(geo, mat);
                
                const h = Math.random() * (CONFIG.treeHeight - 10);
                const r = (1 - h / CONFIG.treeHeight) * CONFIG.treeRadius + 2;
                const angle = (index / total) * Math.PI * 2 + Math.random();
                const px = Math.cos(angle) * r;
                const py = h - CONFIG.treeHeight/2;
                const pz = Math.sin(angle) * r;

                mesh.position.set(px, py, pz);
                mesh.lookAt(0, py, 0);
                mesh.rotateY(Math.PI);
                
                mesh.userData = {
                    treePos: new THREE.Vector3(px, py, pz),
                    treeRot: mesh.rotation.clone(),
                    galleryIndex: index,
                    scale: 1.0
                };
                photoGroup.add(mesh);
                photoMeshes.push(mesh);
             };
        };

        document.getElementById('photo-upload').addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if (!files.length) return;
            
            photoMeshes.forEach(m => photoGroup.remove(m));
            photoMeshes.length = 0;
            currentPhotos.length = 0; // Clear old sharing data

            for(let i=0; i<files.length; i++) {
                const url = URL.createObjectURL(files[i]);
                createPhotoMesh(url, i, files.length);
                // Compress for sharing
                const base64 = await compressImage(files[i]);
                currentPhotos.push(base64);
            }
        });

        // --- æ‰‹åŠ¿äº¤äº’æ ¸å¿ƒé€»è¾‘ ---
        const videoElement = document.getElementById('input-video');
        const statusLeft = document.getElementById('status-left');
        const statusRight = document.getElementById('status-right');
        const statusMode = document.getElementById('status-mode');
        const cursor = document.getElementById('virtual-cursor');

        const getDistance = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

        const onResults = (results) => {
            document.getElementById('loader').style.display = 'none';
            let leftHand = null;
            let rightHand = null;

            if (results.multiHandLandmarks) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const label = results.multiHandedness[i].label;
                    const landmarks = results.multiHandLandmarks[i];
                    if (label === 'Left') leftHand = landmarks;
                    if (label === 'Right') rightHand = landmarks;
                }
            }

            // --- å·¦æ‰‹ï¼šæ§åˆ¶æ•£å¼€/èšåˆ + æ—‹è½¬ (Master Control) ---
            if (leftHand) {
                const dist = getDistance(leftHand[4], leftHand[20]);
                if (dist > 0.15) {
                    statusLeft.innerText = "OPEN (Explode/Rotate)";
                    statusLeft.style.color = "#FF4444";
                    
                    if (!STATE.isExploded) {
                        STATE.isExploded = true;
                        if (!STATE.isFocusing) {
                            STATE.isGalleryMode = true;
                            statusMode.innerText = "Gallery Mode";
                        }
                    }

                    // --- æ–°å¢ï¼šå·¦æ‰‹æ§åˆ¶æ—‹è½¬ ---
                    const wrist = leftHand[0];
                    const handX = wrist.x; 
                    // 0.5 æ˜¯ä¸­å¿ƒï¼Œå·¦å³ç§»åŠ¨äº§ç”Ÿé€Ÿåº¦
                    // å¦‚æœæ‰‹åœ¨å·¦è¾¹ (x < 0.5)ï¼Œvelocity > 0 (å‘å³è½¬)
                    // å¦‚æœæ‰‹åœ¨å³è¾¹ (x > 0.5)ï¼Œvelocity < 0 (å‘å·¦è½¬)
                    STATE.galleryVelocity = (0.5 - handX) * 3.0;

                } else {
                    statusLeft.innerText = "FIST (Reset)";
                    statusLeft.style.color = "#50C878";
                    STATE.isExploded = false;
                    STATE.isGalleryMode = false;
                    STATE.isFocusing = false;
                    STATE.focusTarget = null;
                    STATE.galleryVelocity = 0; // é‡ç½®æ—‹è½¬
                    statusMode.innerText = "Tree Mode";
                }
            } else {
                statusLeft.innerText = "No Hand";
                statusLeft.style.color = "#aaa";
                STATE.galleryVelocity = 0; // æ— æ‰‹æ—¶åœæ­¢æ—‹è½¬
            }

            // --- å³æ‰‹ï¼šç‚¹å‡»ç‰¹å†™ (Selection) ---
            if (rightHand) {
                const thumb = rightHand[4];
                const indexFinger = rightHand[8];
                const cx = (1 - indexFinger.x) * window.innerWidth;
                const cy = indexFinger.y * window.innerHeight;
                STATE.cursorPos.set((cx / window.innerWidth) * 2 - 1, -(cy / window.innerHeight) * 2 + 1);
                
                cursor.style.display = 'block';
                cursor.style.left = `${cx}px`;
                cursor.style.top = `${cy}px`;

                const pinchDist = getDistance(thumb, indexFinger);

                if (STATE.isExploded) {
                    // ç§»é™¤å³æ‰‹æ—‹è½¬é€»è¾‘

                    if (pinchDist < 0.05) {
                        const now = Date.now();
                        if (now - STATE.lastPinchTime > 800) {
                            cursor.classList.add('clicking');
                            statusRight.innerText = "PINCH (Action)";
                            statusRight.style.color = "#50C878";
                            STATE.lastPinchTime = now;

                            if (STATE.isFocusing) {
                                STATE.isFocusing = false;
                                STATE.focusTarget = null;
                                STATE.isGalleryMode = true; 
                                statusMode.innerText = "Back to Gallery";
                            } else {
                                raycaster.setFromCamera(STATE.cursorPos, camera);
                                const intersects = raycaster.intersectObjects(photoMeshes);
                                if (intersects.length > 0) {
                                    const hit = intersects[0].object;
                                    STATE.focusTarget = hit;
                                    STATE.isFocusing = true;
                                    STATE.isGalleryMode = false; 
                                    statusMode.innerText = "Super Close-up!";
                                }
                            }
                        }
                    } else {
                        cursor.classList.remove('clicking');
                        cursor.classList.add('active');
                        statusRight.innerText = "Index to Select"; // æ›´æ–°æç¤º
                        statusRight.style.color = "#D4AF37";
                        if (!STATE.isFocusing) {
                            raycaster.setFromCamera(STATE.cursorPos, camera);
                            const intersects = raycaster.intersectObjects(photoMeshes);
                            photoMeshes.forEach(m => m.userData.isHovered = false);
                            if (intersects.length > 0) {
                                intersects[0].object.userData.isHovered = true;
                            }
                        }
                    }
                } else {
                    statusRight.innerText = "Idle";
                }
            } else {
                statusRight.innerText = "No Hand";
                cursor.style.display = 'none';
            }
        };

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        // --- éŸ³é¢‘ ---
        let analyser, dataArray;
        const setupAudio = (file) => {
            const audioCtx = STATE.audioCtx || new (window.AudioContext || window.webkitAudioContext)();
            STATE.audioCtx = audioCtx;
            
            const audio = new Audio();
            audio.src = URL.createObjectURL(file);
            audio.crossOrigin = "anonymous";
            audio.loop = true;
            
            const source = audioCtx.createMediaElementSource(audio);
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            audio.play();
            
            // Record name for sharing
            STATE.currentMusicName = file.name;
        };

        document.getElementById('music-upload').addEventListener('change', (e) => {
            if(e.target.files[0]) {
                setupAudio(e.target.files[0]);
            }
        });

        document.getElementById('btn-camera').addEventListener('click', async () => {
            document.getElementById('loader').style.display = 'flex';
            document.querySelector('.loader-text').innerText = "Initializing AI Vision...";
            
            // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆè§£å†³è‡ªåŠ¨æ’­æ”¾ç­–ç•¥ï¼‰
            if (!STATE.audioCtx) {
                STATE.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } else if (STATE.audioCtx.state === 'suspended') {
                STATE.audioCtx.resume();
            }

            const cameraUtils = new Camera(videoElement, { 
                onFrame: async () => { await hands.send({image: videoElement}); }, 
                width: 640, height: 480 
            });
            await cameraUtils.start();
            videoElement.style.display = 'block';
        });

        document.getElementById('btn-fullscreen').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => alert("å…¨å±å—é™"));
            else document.exitFullscreen();
        });

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i=0; i<20; i++) sum += dataArray[i];
                STATE.audioData = sum / 20;
            }

            particleMaterial.uniforms.uTime.value = time;
            particleMaterial.uniforms.uAudio.value = THREE.MathUtils.lerp(particleMaterial.uniforms.uAudio.value, STATE.audioData / 255, 0.1);

            const targetExplosion = STATE.isExploded ? 1.0 : 0.0;
            STATE.explosionFactor = THREE.MathUtils.lerp(STATE.explosionFactor, targetExplosion, 3.0 * dt);
            particleMaterial.uniforms.uExplosion.value = STATE.explosionFactor;

            const targetFocus = STATE.isFocusing ? 1.0 : 0.0;
            particleMaterial.uniforms.uFocusMode.value = THREE.MathUtils.lerp(particleMaterial.uniforms.uFocusMode.value, targetFocus, 5.0 * dt);

            if (starMesh) { 
                starMesh.rotation.y += 0.02; 
                starMesh.rotation.z = Math.sin(time) * 0.1; 
            }

            if (STATE.isFocusing && STATE.focusTarget && STATE.isExploded) {
                const targetPos = STATE.focusTarget.position.clone();
                const normal = new THREE.Vector3(0, 0, 1).applyQuaternion(STATE.focusTarget.quaternion);
                const offset = normal.multiplyScalar(15);
                const camTarget = targetPos.clone().add(offset);
                
                camera.position.lerp(camTarget, 0.08);
                controls.target.lerp(targetPos, 0.08);
                controls.autoRotate = false;

                photoMeshes.forEach(mesh => {
                    if (mesh === STATE.focusTarget) {
                        mesh.scale.lerp(new THREE.Vector3(2.5, 2.5, 2.5), 0.1);
                        mesh.lookAt(camera.position); 
                    } else {
                        mesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 0.5), 0.1);
                    }
                });

                 decorationMeshes.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.scatterPos, 0.05);
                    mesh.scale.lerp(new THREE.Vector3(0, 0, 0), 0.1); 
                });

            } else if (STATE.isExploded && STATE.isGalleryMode) {
                camera.position.lerp(STATE.galleryCameraPos, 0.03);
                controls.target.lerp(new THREE.Vector3(0, 30, 0), 0.03);
                controls.autoRotate = false;

                STATE.galleryRotation += STATE.galleryVelocity * dt;

                const count = photoMeshes.length;
                const ringRadius = Math.max(30, (count * 8) / (2 * Math.PI)); 
                const angleStep = (Math.PI * 2) / (count || 1);

                photoMeshes.forEach((mesh, i) => {
                    const angle = i * angleStep + STATE.galleryRotation;
                    const targetX = ringRadius * Math.sin(angle);
                    const targetZ = ringRadius * Math.cos(angle);
                    const targetY = 30 + Math.sin(time + i * 0.5) * 1.5; 

                    const worldTarget = new THREE.Vector3(targetX, targetY, targetZ);
                    mesh.position.lerp(worldTarget, 0.1);
                    mesh.lookAt(0, 30, 0); 
                    mesh.rotateY(Math.PI);
                    
                    let targetScale = 1.5; 
                    if (mesh.userData.isHovered) targetScale = 1.8;
                    mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                });

                decorationMeshes.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.scatterPos, 0.05);
                    mesh.scale.lerp(mesh.userData.treeScale, 0.1);
                    mesh.rotation.x += dt; 
                });

            } else if (STATE.isExploded && !STATE.isGalleryMode) {
                photoMeshes.forEach((mesh, i) => {
                    const treePos = mesh.userData.treePos;
                    const scatterTarget = treePos.clone().normalize().multiplyScalar(40);
                    mesh.position.lerp(scatterTarget, 0.05);
                    mesh.lookAt(0, 0, 0);
                });
                decorationMeshes.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.scatterPos, 0.05);
                    mesh.scale.lerp(mesh.userData.treeScale, 0.1);
                    mesh.rotation.x += dt;
                });

            } else {
                camera.position.lerp(STATE.originalCameraPos, 0.05);
                controls.target.lerp(new THREE.Vector3(0, 0, 0), 0.05);
                controls.autoRotate = true;
                scene.rotation.y = 0; 

                photoMeshes.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.treePos, 0.05);
                    const targetRot = mesh.userData.treeRot;
                    mesh.rotation.x = THREE.MathUtils.lerp(mesh.rotation.x, targetRot.x, 0.05);
                    mesh.rotation.y = THREE.MathUtils.lerp(mesh.rotation.y, targetRot.y, 0.05);
                    mesh.rotation.z = THREE.MathUtils.lerp(mesh.rotation.z, targetRot.z, 0.05);
                    mesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                });

                decorationMeshes.forEach(mesh => {
                    mesh.position.lerp(mesh.userData.treePos, 0.05);
                    mesh.scale.lerp(mesh.userData.treeScale, 0.1);
                    if(mesh.userData.treeRot) {
                        mesh.rotation.x = THREE.MathUtils.lerp(mesh.rotation.x, mesh.userData.treeRot.x, 0.05);
                        mesh.rotation.y = THREE.MathUtils.lerp(mesh.rotation.y, mesh.userData.treeRot.y, 0.05);
                        mesh.rotation.z = THREE.MathUtils.lerp(mesh.rotation.z, mesh.userData.treeRot.z, 0.05);
                    }
                });
            }

            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            particleMaterial.uniforms.uPixelRatio.value = renderer.getPixelRatio();
        });

        // Initialize Firebase
        initFirebase();

        // åˆå§‹ç§»é™¤ Loading
        setTimeout(() => {
            const loader = document.getElementById('loader');
            if(loader.style.display !== 'none' && document.querySelector('.loader-text').innerText === "Loading Experience...") {
                loader.style.display = 'none';
            }
        }, 2000);

    </script>
</body>
</html>